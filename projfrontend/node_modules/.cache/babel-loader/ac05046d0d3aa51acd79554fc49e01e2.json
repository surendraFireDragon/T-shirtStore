{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFocusable = isFocusable;\nexports.isClickable = isClickable;\nexports.getMouseEventOptions = getMouseEventOptions;\nexports.isLabelWithInternallyDisabledControl = isLabelWithInternallyDisabledControl;\nexports.getActiveElement = getActiveElement;\nexports.calculateNewValue = calculateNewValue;\nexports.setSelectionRangeIfNecessary = setSelectionRangeIfNecessary;\nexports.eventWrapper = eventWrapper;\nexports.isValidDateValue = isValidDateValue;\nexports.getValue = getValue;\nexports.getSelectionRange = getSelectionRange;\nexports.isContentEditable = isContentEditable;\nexports.FOCUSABLE_SELECTOR = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nfunction isMousePressEvent(event) {\n  return event === 'mousedown' || event === 'mouseup' || event === 'click' || event === 'dblclick';\n}\n\nfunction invert(map) {\n  const res = {};\n\n  for (const key of Object.keys(map)) {\n    res[map[key]] = key;\n  }\n\n  return res;\n} // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n\n\nconst BUTTONS_TO_NAMES = {\n  0: 'none',\n  1: 'primary',\n  2: 'secondary',\n  4: 'auxiliary'\n};\nconst NAMES_TO_BUTTONS = invert(BUTTONS_TO_NAMES); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n\nconst BUTTON_TO_NAMES = {\n  0: 'primary',\n  1: 'auxiliary',\n  2: 'secondary'\n};\nconst NAMES_TO_BUTTON = invert(BUTTON_TO_NAMES);\n\nfunction convertMouseButtons(event, init, property, mapping) {\n  if (!isMousePressEvent(event)) {\n    return 0;\n  }\n\n  if (init[property] != null) {\n    return init[property];\n  }\n\n  if (init.buttons != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTONS_TO_NAMES[init.buttons]] || 0;\n  }\n\n  if (init.button != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTON_TO_NAMES[init.button]] || 0;\n  }\n\n  return property != 'button' && isMousePressEvent(event) ? 1 : 0;\n}\n\nfunction getMouseEventOptions(event, init, clickCount = 0) {\n  init = init || {};\n  return { ...init,\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n    detail: event === 'mousedown' || event === 'mouseup' || event === 'click' ? 1 + clickCount : clickCount,\n    buttons: convertMouseButtons(event, init, 'buttons', NAMES_TO_BUTTONS),\n    button: convertMouseButtons(event, init, 'button', NAMES_TO_BUTTON)\n  };\n} // Absolutely NO events fire on label elements that contain their control\n// if that control is disabled. NUTS!\n// no joke. There are NO events for: <label><input disabled /><label>\n\n\nfunction isLabelWithInternallyDisabledControl(element) {\n  var _element$control;\n\n  return element.tagName === 'LABEL' && ((_element$control = element.control) == null ? void 0 : _element$control.disabled) && element.contains(element.control);\n}\n\nfunction getActiveElement(document) {\n  const activeElement = document.activeElement;\n\n  if (activeElement == null ? void 0 : activeElement.shadowRoot) {\n    return getActiveElement(activeElement.shadowRoot);\n  } else {\n    return activeElement;\n  }\n}\n\nfunction supportsMaxLength(element) {\n  if (element.tagName === 'TEXTAREA') return true;\n\n  if (element.tagName === 'INPUT') {\n    const type = element.getAttribute('type'); // Missing value default is \"text\"\n\n    if (!type) return true; // https://html.spec.whatwg.org/multipage/input.html#concept-input-apply\n\n    if (type.match(/email|password|search|telephone|text|url/)) return true;\n  }\n\n  return false;\n}\n\nfunction getSelectionRange(element) {\n  if (isContentEditable(element)) {\n    const range = element.ownerDocument.getSelection().getRangeAt(0);\n    return {\n      selectionStart: range.startOffset,\n      selectionEnd: range.endOffset\n    };\n  }\n\n  return {\n    selectionStart: element.selectionStart,\n    selectionEnd: element.selectionEnd\n  };\n} //jsdom is not supporting isContentEditable\n\n\nfunction isContentEditable(element) {\n  return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');\n}\n\nfunction getValue(element) {\n  if (isContentEditable(element)) {\n    return element.textContent;\n  }\n\n  return element.value;\n}\n\nfunction calculateNewValue(newEntry, element) {\n  var _element$getAttribute;\n\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n  const value = getValue(element); // can't use .maxLength property because of a jsdom bug:\n  // https://github.com/jsdom/jsdom/issues/2927\n\n  const maxLength = Number((_element$getAttribute = element.getAttribute('maxlength')) != null ? _element$getAttribute : -1);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value + newEntry;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = newEntry + value;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value + newEntry;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + newEntry + value.slice(selectionEnd);\n    }\n\n    newSelectionStart = selectionStart + newEntry.length;\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart) + newEntry;\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  if (element.type === 'date' && !isValidDateValue(element, newValue)) {\n    newValue = value;\n  }\n\n  if (!supportsMaxLength(element) || maxLength < 0) {\n    return {\n      newValue,\n      newSelectionStart\n    };\n  } else {\n    return {\n      newValue: newValue.slice(0, maxLength),\n      newSelectionStart: newSelectionStart > maxLength ? maxLength : newSelectionStart\n    };\n  }\n}\n\nfunction setSelectionRangeIfNecessary(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n\n  if (!isContentEditable(element) && (!element.setSelectionRange || selectionStart === null)) {\n    // cannot set selection\n    return;\n  }\n\n  if (selectionStart !== newSelectionStart || selectionEnd !== newSelectionStart) {\n    if (isContentEditable(element)) {\n      const range = element.ownerDocument.createRange();\n      range.selectNodeContents(element);\n      range.setStart(element.firstChild, newSelectionStart);\n      range.setEnd(element.firstChild, newSelectionEnd);\n      element.ownerDocument.getSelection().removeAllRanges();\n      element.ownerDocument.getSelection().addRange(range);\n    } else {\n      element.setSelectionRange(newSelectionStart, newSelectionEnd);\n    }\n  }\n}\n\nconst FOCUSABLE_SELECTOR = ['input:not([type=hidden]):not([disabled])', 'button:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', '[contenteditable=\"\"]', '[contenteditable=\"true\"]', 'a[href]', '[tabindex]:not([disabled])'].join(', ');\nexports.FOCUSABLE_SELECTOR = FOCUSABLE_SELECTOR;\n\nfunction isFocusable(element) {\n  return !isLabelWithInternallyDisabledControl(element) && (element == null ? void 0 : element.matches(FOCUSABLE_SELECTOR));\n}\n\nconst CLICKABLE_INPUT_TYPES = ['button', 'color', 'file', 'image', 'reset', 'submit'];\n\nfunction isClickable(element) {\n  return element.tagName === 'BUTTON' || element instanceof element.ownerDocument.defaultView.HTMLInputElement && CLICKABLE_INPUT_TYPES.includes(element.type);\n}\n\nfunction eventWrapper(cb) {\n  let result;\n  (0, _dom.getConfig)().eventWrapper(() => {\n    result = cb();\n  });\n  return result;\n}\n\nfunction isValidDateValue(element, value) {\n  if (element.type !== 'date') return false;\n  const clone = element.cloneNode();\n  clone.value = value;\n  return clone.value === value;\n}","map":{"version":3,"sources":["/Users/surendrapratapsingh/Desktop/MERNBootCamp/projfrontend/node_modules/@testing-library/user-event/dist/utils.js"],"names":["Object","defineProperty","exports","value","isFocusable","isClickable","getMouseEventOptions","isLabelWithInternallyDisabledControl","getActiveElement","calculateNewValue","setSelectionRangeIfNecessary","eventWrapper","isValidDateValue","getValue","getSelectionRange","isContentEditable","FOCUSABLE_SELECTOR","_dom","require","isMousePressEvent","event","invert","map","res","key","keys","BUTTONS_TO_NAMES","NAMES_TO_BUTTONS","BUTTON_TO_NAMES","NAMES_TO_BUTTON","convertMouseButtons","init","property","mapping","buttons","button","clickCount","detail","element","_element$control","tagName","control","disabled","contains","document","activeElement","shadowRoot","supportsMaxLength","type","getAttribute","match","range","ownerDocument","getSelection","getRangeAt","selectionStart","startOffset","selectionEnd","endOffset","hasAttribute","textContent","newEntry","_element$getAttribute","maxLength","Number","newValue","newSelectionStart","length","slice","firstPart","newSelectionEnd","setSelectionRange","createRange","selectNodeContents","setStart","firstChild","setEnd","removeAllRanges","addRange","join","matches","CLICKABLE_INPUT_TYPES","defaultView","HTMLInputElement","includes","cb","result","getConfig","clone","cloneNode"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFocusable = isFocusable;\nexports.isClickable = isClickable;\nexports.getMouseEventOptions = getMouseEventOptions;\nexports.isLabelWithInternallyDisabledControl = isLabelWithInternallyDisabledControl;\nexports.getActiveElement = getActiveElement;\nexports.calculateNewValue = calculateNewValue;\nexports.setSelectionRangeIfNecessary = setSelectionRangeIfNecessary;\nexports.eventWrapper = eventWrapper;\nexports.isValidDateValue = isValidDateValue;\nexports.getValue = getValue;\nexports.getSelectionRange = getSelectionRange;\nexports.isContentEditable = isContentEditable;\nexports.FOCUSABLE_SELECTOR = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nfunction isMousePressEvent(event) {\n  return event === 'mousedown' || event === 'mouseup' || event === 'click' || event === 'dblclick';\n}\n\nfunction invert(map) {\n  const res = {};\n\n  for (const key of Object.keys(map)) {\n    res[map[key]] = key;\n  }\n\n  return res;\n} // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n\n\nconst BUTTONS_TO_NAMES = {\n  0: 'none',\n  1: 'primary',\n  2: 'secondary',\n  4: 'auxiliary'\n};\nconst NAMES_TO_BUTTONS = invert(BUTTONS_TO_NAMES); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n\nconst BUTTON_TO_NAMES = {\n  0: 'primary',\n  1: 'auxiliary',\n  2: 'secondary'\n};\nconst NAMES_TO_BUTTON = invert(BUTTON_TO_NAMES);\n\nfunction convertMouseButtons(event, init, property, mapping) {\n  if (!isMousePressEvent(event)) {\n    return 0;\n  }\n\n  if (init[property] != null) {\n    return init[property];\n  }\n\n  if (init.buttons != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTONS_TO_NAMES[init.buttons]] || 0;\n  }\n\n  if (init.button != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTON_TO_NAMES[init.button]] || 0;\n  }\n\n  return property != 'button' && isMousePressEvent(event) ? 1 : 0;\n}\n\nfunction getMouseEventOptions(event, init, clickCount = 0) {\n  init = init || {};\n  return { ...init,\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n    detail: event === 'mousedown' || event === 'mouseup' || event === 'click' ? 1 + clickCount : clickCount,\n    buttons: convertMouseButtons(event, init, 'buttons', NAMES_TO_BUTTONS),\n    button: convertMouseButtons(event, init, 'button', NAMES_TO_BUTTON)\n  };\n} // Absolutely NO events fire on label elements that contain their control\n// if that control is disabled. NUTS!\n// no joke. There are NO events for: <label><input disabled /><label>\n\n\nfunction isLabelWithInternallyDisabledControl(element) {\n  var _element$control;\n\n  return element.tagName === 'LABEL' && ((_element$control = element.control) == null ? void 0 : _element$control.disabled) && element.contains(element.control);\n}\n\nfunction getActiveElement(document) {\n  const activeElement = document.activeElement;\n\n  if (activeElement == null ? void 0 : activeElement.shadowRoot) {\n    return getActiveElement(activeElement.shadowRoot);\n  } else {\n    return activeElement;\n  }\n}\n\nfunction supportsMaxLength(element) {\n  if (element.tagName === 'TEXTAREA') return true;\n\n  if (element.tagName === 'INPUT') {\n    const type = element.getAttribute('type'); // Missing value default is \"text\"\n\n    if (!type) return true; // https://html.spec.whatwg.org/multipage/input.html#concept-input-apply\n\n    if (type.match(/email|password|search|telephone|text|url/)) return true;\n  }\n\n  return false;\n}\n\nfunction getSelectionRange(element) {\n  if (isContentEditable(element)) {\n    const range = element.ownerDocument.getSelection().getRangeAt(0);\n    return {\n      selectionStart: range.startOffset,\n      selectionEnd: range.endOffset\n    };\n  }\n\n  return {\n    selectionStart: element.selectionStart,\n    selectionEnd: element.selectionEnd\n  };\n} //jsdom is not supporting isContentEditable\n\n\nfunction isContentEditable(element) {\n  return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');\n}\n\nfunction getValue(element) {\n  if (isContentEditable(element)) {\n    return element.textContent;\n  }\n\n  return element.value;\n}\n\nfunction calculateNewValue(newEntry, element) {\n  var _element$getAttribute;\n\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n  const value = getValue(element); // can't use .maxLength property because of a jsdom bug:\n  // https://github.com/jsdom/jsdom/issues/2927\n\n  const maxLength = Number((_element$getAttribute = element.getAttribute('maxlength')) != null ? _element$getAttribute : -1);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value + newEntry;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = newEntry + value;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value + newEntry;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + newEntry + value.slice(selectionEnd);\n    }\n\n    newSelectionStart = selectionStart + newEntry.length;\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart) + newEntry;\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  if (element.type === 'date' && !isValidDateValue(element, newValue)) {\n    newValue = value;\n  }\n\n  if (!supportsMaxLength(element) || maxLength < 0) {\n    return {\n      newValue,\n      newSelectionStart\n    };\n  } else {\n    return {\n      newValue: newValue.slice(0, maxLength),\n      newSelectionStart: newSelectionStart > maxLength ? maxLength : newSelectionStart\n    };\n  }\n}\n\nfunction setSelectionRangeIfNecessary(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n\n  if (!isContentEditable(element) && (!element.setSelectionRange || selectionStart === null)) {\n    // cannot set selection\n    return;\n  }\n\n  if (selectionStart !== newSelectionStart || selectionEnd !== newSelectionStart) {\n    if (isContentEditable(element)) {\n      const range = element.ownerDocument.createRange();\n      range.selectNodeContents(element);\n      range.setStart(element.firstChild, newSelectionStart);\n      range.setEnd(element.firstChild, newSelectionEnd);\n      element.ownerDocument.getSelection().removeAllRanges();\n      element.ownerDocument.getSelection().addRange(range);\n    } else {\n      element.setSelectionRange(newSelectionStart, newSelectionEnd);\n    }\n  }\n}\n\nconst FOCUSABLE_SELECTOR = ['input:not([type=hidden]):not([disabled])', 'button:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', '[contenteditable=\"\"]', '[contenteditable=\"true\"]', 'a[href]', '[tabindex]:not([disabled])'].join(', ');\nexports.FOCUSABLE_SELECTOR = FOCUSABLE_SELECTOR;\n\nfunction isFocusable(element) {\n  return !isLabelWithInternallyDisabledControl(element) && (element == null ? void 0 : element.matches(FOCUSABLE_SELECTOR));\n}\n\nconst CLICKABLE_INPUT_TYPES = ['button', 'color', 'file', 'image', 'reset', 'submit'];\n\nfunction isClickable(element) {\n  return element.tagName === 'BUTTON' || element instanceof element.ownerDocument.defaultView.HTMLInputElement && CLICKABLE_INPUT_TYPES.includes(element.type);\n}\n\nfunction eventWrapper(cb) {\n  let result;\n  (0, _dom.getConfig)().eventWrapper(() => {\n    result = cb();\n  });\n  return result;\n}\n\nfunction isValidDateValue(element, value) {\n  if (element.type !== 'date') return false;\n  const clone = element.cloneNode();\n  clone.value = value;\n  return clone.value === value;\n}"]},"metadata":{},"sourceType":"script"}